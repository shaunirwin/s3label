<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="static/fetch_data.js"></script>
    <script src="static/polygon_operations.js"></script>
    <script src="node_modules\polybooljs\dist\polybool.js"></script>
    <!-- <script src="node_modules\polybooljs\dist\bundle.js"></script> -->
    <!-- <script src="node_modules\poly-bool\bundle.js"></script> -->
    <!-- <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script> -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" crossorigin="anonymous">
    <title>S3 Label</title>
</head>

<body>

    <div class="container">

        <h1>S3 Label</h1>

        <div id="drawingtools">
            <div class="row">
                <div id="tools" class="col">
                    <span>Tools</span>
                    <form>
                        <input type="radio" name="tool" value="freehand" checked> Freehand
                        <br>
                        <input type="radio" name="tool" value="polygon"> Polygon
                    </form>
                </div>
                <div id="semantic_labels" class="col">
                    <span>Semantic Labels</span>
                    <form>
                        <input type="radio" name="semantic_label" value="individual_rock" checked> Individual rock
                        <br>
                        <input type="radio" name="semantic_label" value="belt"> Belt
                        <br>
                        <input type="radio" name="semantic_label" value="other"> Other
                    </form>
                </div>
                <div id="graphics_settings" class="col">
                    <div id="stroke_slider_container">
                        <span>Stroke thickness</span>
                        <input id="stroke_thickness_slider" type="range" min="0" max="10" value="2" class="slider">
                    </div>
                    <div id="opacity_slider_container">
                        <span>Opacity</span>
                        <input id="opacity_slider" type="range" min="0" max="100" value="50" class="slider">
                    </div>
                </div>
                <div id="clear_canvas_container" class="col">
                    <button type="submit" onclick="clearCanvas();">Clear canvas</button>
                </div>
            </div>
        </div>

        <div id="canvasesdiv" style="position:relative; ">
            <canvas id="canvas-fg" width="900" height="350" style="width:900px;height:350px; border: 1px solid #ccc; z-index: 2; position:absolute; left:0px; top:0px;"></canvas>
            <canvas id="canvas-bg" width="900" height="350" style="width:900px;height:350px; border: 1px solid #ccc; z-index: 1; position:absolute; left:0px; top:0px;"></canvas>
            <!-- width:900px;height:350px; -->
        </div>
    </div>

    <script>
        var el = document.getElementById('canvas-fg');
        var el2 = document.getElementById('canvas-bg');
        var ctx = el.getContext('2d');
        var ctx_bg = el2.getContext('2d');
        var stroke_thickness_slider = document.getElementById("stroke_thickness_slider");
        var opacity_slider = document.getElementById("opacity_slider");

        var isDrawing;
        var paths = [];
        var currentPath = [];
        var paths_redo = [];
        var colours = {
            'individual_rock': [255, 0, 0],
            'belt': [0, 255, 0],
            'other': [0, 0, 255]
        };
        var padX = padY = 80;
        var use_stroke = true;
        var opacity = opacity_slider.value / 100.;
        var active_label = 'individual_rock';
        var active_tool = document.querySelector('input[name="tool"]:checked').value;

        var counter = 0;    // testing purposes

        ctx.lineWidth = stroke_thickness_slider.value;
        // ctx.setLineDash([]);
        // ctx.setLineDash([4, 4]);
        ctx.fillStyle = setColour(colours[active_label], opacity);

        window.addEventListener('keydown', this.keyHandler, false);

        function keyHandler(e) {
            if (e.ctrlKey && e.code === "KeyZ") {
                console.log("Undo");
                undo();
                drawAllPolygons(ctx, paths);
            }
            else if (e.ctrlKey && e.code === "KeyY") {
                console.log("Redo");
                redo();
                drawAllPolygons(ctx, paths);
            }
            else if (e.code === "KeyA") {
                fetchAndDisplayImage('http://127.0.0.1:5000/image_labeler/api/v1.0/input_images/1');
            }
            else if (e.code === "KeyB") {
                fetchAndDisplayImage('http://127.0.0.1:5000/image_labeler/api/v1.0/input_images/2');
            }
            else if (e.code === "KeyC") {
                fetchAndDisplayImage('http://127.0.0.1:5000/image_labeler/api/v1.0/input_images/3');
            }

            e.stopPropagation();
            e.preventDefault();
        }

        function getMousePos(canvas, event) {
            // https://stackoverflow.com/questions/17130395/real-mouse-position-in-canvas
            var rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        el.onmousedown = function (e) {
            paths_redo = [];
            isDrawing = true;
            ctx.lineJoin = ctx.lineCap = 'round';
            ctx.beginPath();
            coords = getMousePos(ctx.canvas, e);
            if (coords.x == undefined || coords.y == undefined) {
                console.log("coords undef:" + coords);
            }
            ctx.moveTo(coords.x, coords.y);
            currentPath.push([coords.x, coords.y]);
        };
        el.onmousemove = function (e) {
            if (isDrawing) {
                coords = getMousePos(ctx.canvas, e);
                if (coords.x == undefined || coords.y == undefined) {
                    console.log("coords undef:" + coords);
                }
                ctx.lineTo(coords.x, coords.y);
                ctx.stroke();
                currentPath.push([coords.x, coords.y]);
            }
        };
        el.onmouseup = function () {
            isDrawing = false;

            ctx.closePath();
            if (use_stroke) {
                ctx.stroke();
            }
            ctx.fill();

            console.log("currentPath: " + currentPath);

            let currentPolygon = convertPathToPolygon(currentPath);

            if (counter < 3) {
                // subtract all previous paths from this new path
                for (var i = 0; i < paths.length; i++) {
                    let poly = convertPathToPolygon(paths[i].path);

                    // 
                    currentPolygon = PolyBool.difference(currentPolygon, poly);
                }

                if (currentPolygon.regions.length > 0) {
                    paths.push({ 'path': convertPolygonToPath(currentPolygon), 'label': active_label, 'type': active_tool });
                }
                console.log('new poly');
            }
            else if (counter < 6) {
                // append to last polygon
                let poly = convertPathToPolygon(paths[paths.length - 1].path);
                currentPolygon = PolyBool.union(currentPolygon, poly);

                if (currentPolygon.regions.length > 0) {
                    paths[paths.length - 1] = { 'path': convertPolygonToPath(currentPolygon), 'label': active_label, 'type': active_tool };
                }
                console.log('append poly');
            }
            else {
                // subtract from last polygon
                let poly = convertPathToPolygon(paths[paths.length - 1].path);
                currentPolygon = PolyBool.difference(poly, currentPolygon);

                if (currentPolygon.regions.length > 0) {
                    paths[paths.length - 1] = { 'path': convertPolygonToPath(currentPolygon), 'label': active_label, 'type': active_tool };
                }
                console.log('erase poly');
            }

            // console.log('currentPolygon:', currentPolygon);

            currentPath = [];

            drawAllPolygons(ctx, paths);
            counter ++;
        };

        function undo() {
            if (paths.length > 0) {
                paths_redo.push(paths.pop());
            }
        }

        function redo() {
            if (paths_redo.length > 0) {
                paths.push(paths_redo.pop());
            }
        }

        function drawAllPolygons(context, path_list) {
            context.clearRect(0, 0, context.canvas.width, context.canvas.height);

            for (let i = 0; i < path_list.length; i++) {
                setColour(colours[path_list[i].label], opacity);
                drawPolygon(context, path_list[i].path);
                // console.log("Drawing polygon " + i + ' label: ' + path_list[i].label + ' colour: ' + context.fillStyle);
            }
            // console.log("Num paths:" + path_list.length);
        }

        function drawPolygon(context, path) {
            let w = context.canvas.width;
            let h = context.canvas.height;

            context.beginPath();
            context.moveTo(Math.max(padX, Math.min(path[0][0], w - padX)),
                Math.max(padY, Math.min(path[0][1], h - padY)));

            for (let i = 1; i < path.length; i++) {
                context.lineTo(Math.max(padX, Math.min(path[i][0], w - padX)),
                    Math.max(padY, Math.min(path[i][1], h - padY)));
            }

            context.closePath();
            if (use_stroke) {
                context.stroke();
            }
            context.fill();
        }

        // detect tool and colour changes

        var toolRadioButtons = document.getElementsByName("tool");
        var semanticLabelRadioButtons = document.getElementsByName("semantic_label");

        for (var i = 0; toolRadioButtons[i]; i++)
            toolRadioButtons[i].onclick = setActiveTool;

        for (var i = 0; semanticLabelRadioButtons[i]; i++)
            semanticLabelRadioButtons[i].onclick = setActiveLabel;

        function setActiveTool() {
            active_tool = document.querySelector('input[name="tool"]:checked').value;
            console.log("active_tool: " + active_tool);
        }

        function formatColour(rgb, alpha) {
            return 'rgba(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ',' + alpha + ')';
        }

        function setColour(rgb, alpha) {
            ctx.fillStyle = formatColour(rgb, alpha);
        }

        function setActiveLabel() {
            active_label = label_class = document.querySelector('input[name="semantic_label"]:checked').value;
            setColour(colours[active_label], opacity);
            console.log("active_label: " + active_label);
        }

        // detect stroke thickness and opacity slider changes

        stroke_thickness_slider.oninput = function () {

            if (this.value > 0) {
                ctx.lineWidth = this.value;
                use_stroke = true;
            }
            else {
                ctx.lineWidth = 1;
                use_stroke = false;
            }

            drawAllPolygons(ctx, paths);
        }

        opacity_slider.oninput = function () {
            opacity = this.value / 100.;

            drawAllPolygons(ctx, paths);
        }

        // clear canvas

        function clearCanvas() {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            paths = [];
            paths_redo = [];
        }
    </script>
</body>

</html>